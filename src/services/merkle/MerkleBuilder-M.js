// src/services/merkle/MerkleBuilder-M.js
import { HashingService } from '../hashing/HashingService';

/**
 * A collection of pure, stateless functions for Merkle tree construction and verification.
 * This service is the cryptographic foundation for the Unified Merkle Publishing architecture.
 */
class MerkleBuilderM {
  /**
   * Hashes two sibling hashes together to produce a parent hash.
   * Ensures deterministic ordering by sorting hashes lexicographically before concatenation.
   * @param {string} hashA - The first hash.
   * @param {string} hashB - The second hash.
   * @returns {Promise<string>} The resulting parent hash.
   * @private
   */
  static async _hashPair(hashA, hashB) {
    const sortedHashes = [hashA, hashB].sort((a, b) => a.localeCompare(b));
    return HashingService(sortedHashes[0] + sortedHashes[1]);
  }

  /**
   * Builds a full Merkle tree from an array of leaf data.
   * @param {string[]} leafData - An array of strings representing the data for the leaf nodes.
   * IMPORTANT: The data must be in the correct, final order.
   * @returns {Promise<{root: string, levels: string[][]}>} An object containing the Merkle root and all levels of the tree.
   */
  static async buildTree(leafData) {
    console.log('MerkleBuilder-M.js: buildTree: Building tree with', leafData.length, 'leaves.');
    if (!leafData || leafData.length === 0) {
      throw new Error('Cannot build a Merkle tree with no leaf data.');
    }

    const levels = [];
    let currentLevel = await Promise.all(leafData.map(data => HashingService(data)));
    levels.push(currentLevel);

    while (currentLevel.length > 1) {
      const nextLevel = [];
      for (let i = 0; i < currentLevel.length; i += 2) {
        const left = currentLevel[i];
        // If there's an odd number of nodes, duplicate the last one to hash it with itself
        const right = (i + 1 < currentLevel.length) ? currentLevel[i + 1] : left;
        const parentHash = await this._hashPair(left, right);
        nextLevel.push(parentHash);
      }
      currentLevel = nextLevel;
      levels.push(currentLevel);
    }

    const root = levels[levels.length - 1][0];
    console.log('MerkleBuilder-M.js: buildTree: Tree built successfully. Root:', root);
    return { root, levels };
  }

  /**
   * Generates a Merkle proof (the list of sibling hashes) for a specific leaf.
   * @param {{levels: string[][]}} tree - The full tree object generated by `buildTree`.
   * @param {number} leafIndex - The index of the leaf for which to generate the proof.
   * @returns {Array<{hash: string, position: 'left' | 'right'}>} The proof, which is an array of sibling hashes and their positions.
   */
  static getProof(tree, leafIndex) {
    console.log(`MerkleBuilder-M.js: getProof: Generating proof for leaf index ${leafIndex}.`);
    if (!tree || !tree.levels || tree.levels.length === 0) {
      throw new Error('Invalid tree provided to getProof.');
    }
    if (leafIndex < 0 || leafIndex >= tree.levels[0].length) {
        throw new Error('Leaf index is out of bounds.');
    }

    const proof = [];
    let currentIndex = leafIndex;

    for (let i = 0; i < tree.levels.length - 1; i++) {
      const currentLevel = tree.levels[i];
      const isOdd = currentIndex % 2 !== 0;
      const siblingIndex = isOdd ? currentIndex - 1 : currentIndex + 1;

      if (siblingIndex < currentLevel.length) {
        proof.push({
          hash: currentLevel[siblingIndex],
          position: isOdd ? 'left' : 'right',
        });
      }
      // For the next level, the index is halved and floored
      currentIndex = Math.floor(currentIndex / 2);
    }
    
    console.log(`MerkleBuilder-M.js: getProof: Proof generated with ${proof.length} hashes.`);
    return proof;
  }

  /**
   * Verifies a leaf against a Merkle root using its proof.
   * @param {string} leafData - The original data of the leaf to verify.
   * @param {Array<{hash: string, position: 'left' | 'right'}>} proof - The Merkle proof for the leaf.
   * @param {string} expectedRoot - The expected Merkle root hash.
   * @returns {Promise<boolean>} True if the proof is valid, false otherwise.
   */
  static async verifyProof(leafData, proof, expectedRoot) {
    console.log('MerkleBuilder-M.js: verifyProof: Verifying proof against root', expectedRoot);
    let computedHash = await HashingService(leafData);

    for (const proofElement of proof) {
      if (proofElement.position === 'left') {
        computedHash = await this._hashPair(proofElement.hash, computedHash);
      } else {
        computedHash = await this._hashPair(computedHash, proofElement.hash);
      }
    }

    const isValid = computedHash === expectedRoot;
    console.log('MerkleBuilder-M.js: verifyProof: Verification result:', isValid);
    return isValid;
  }
}

export default MerkleBuilderM;

// 5122